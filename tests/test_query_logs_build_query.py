# Auto-generated by codex_workflow.py @ 2025-08-19T20:32:56Z
import ast
import importlib.util
import inspect
import pathlib
import re

import pytest

ROOT = pathlib.Path(__file__).resolve().parents[1]
CANDIDATES = [
    "src/codex/logging/query_logs.py",
    "src/codex/logging/viewer.py",
    "scripts/codex_end_to_end.py",
]


def _load_module_from_path(rel_path):
    mod_path = ROOT / rel_path
    spec = importlib.util.spec_from_file_location("build_query_mod", str(mod_path))
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)  # type: ignore
    return mod


def _load_build_query():
    last_err = None
    for rel in CANDIDATES:
        try:
            mod = _load_module_from_path(rel)
            if hasattr(mod, "build_query"):
                return getattr(mod, "build_query"), mod
        except Exception as e:  # pragma: no cover - best effort
            last_err = e
            continue
    if last_err:
        pytest.xfail(f"build_query not importable from candidates: {last_err}")
    pytest.xfail("build_query not importable from any candidate")


def _extract_literal_columns_from_source(src: str):
    out = set()
    try:
        tree = ast.parse(src)
        for node in ast.walk(tree):
            if isinstance(node, ast.Assign):
                for target in node.targets:
                    if isinstance(target, ast.Name) and re.search(
                        r"^(columns|select|select_cols|cols)$", target.id, re.I
                    ):
                        if isinstance(node.value, (ast.List, ast.Tuple)):
                            for elt in node.value.elts:
                                if isinstance(elt, ast.Constant) and isinstance(
                                    elt.value, str
                                ):
                                    out.add(elt.value)
            if isinstance(node, ast.AnnAssign) and isinstance(node.target, ast.Name):
                if re.search(
                    r"^(columns|select|select_cols|cols)$", node.target.id, re.I
                ):
                    v = node.value
                    if isinstance(v, (ast.List, ast.Tuple)):
                        for elt in v.elts:
                            if isinstance(elt, ast.Constant) and isinstance(
                                elt.value, str
                            ):
                                out.add(elt.value)
    except Exception:
        pass
    for m in re.finditer(r"SELECT\s+(.+?)\s+FROM", src, flags=re.I | re.S):
        cols = [c.strip(' `"') for c in re.split(r",\s*", m.group(1))]
        out.update(
            [
                c
                for c in cols
                if c
                and all(
                    x not in c.lower() for x in ["*", "case ", "count(", "sum(", "avg("]
                )
            ]
        )
    return [c for c in out if re.match(r"[A-Za-z_][A-Za-z0-9_]*$", c)]


def _extract_timestamp_from_source(src: str):
    m = re.search(
        r"ORDER\s+BY\s+([A-Za-z_][A-Za-z0-9_]*)\s+(ASC|DESC)", src, flags=re.I
    )
    if m:
        return m.group(1)
    m = re.search(
        r"(timestamp|ts_col|order_by|sort_key)\s*=\s*['\"]([A-Za-z_][A-Za-z0-9_]*)['\"]",
        src,
        flags=re.I,
    )
    if m:
        return m.group(2)
    return None


def _infer_expectations(build_query):
    expected_cols = []
    ts = None
    try:
        src = inspect.getsource(build_query)
        expected_cols = _extract_literal_columns_from_source(src)
        ts = _extract_timestamp_from_source(src)
    except Exception:
        pass
    try:
        sig = inspect.signature(build_query)
        params = [p for p in sig.parameters]
        if not ts:
            if "timestamp" in params:
                ts = "timestamp"
            elif "order_by" in params:
                ts = "order_by"
        if not expected_cols:
            if "columns" in params or "select" in params:
                expected_cols = ["event_time", "user_id", "message"]
    except Exception:
        pass
    if not expected_cols:
        expected_cols = ["event_time", "user_id", "message"]
    if not ts:
        ts = "event_time"
    return expected_cols, ts


def _extract_select_cols(sql: str):
    m = re.search(r"select\s+(.*?)\s+from", sql, flags=re.I | re.S)
    if not m:
        return []
    cols = [c.strip() for c in re.split(r",\s*", m.group(1))]
    return [re.sub(r"\s+as\s+\w+$", "", c, flags=re.I) for c in cols]


def test_build_query_selects_columns_and_orders():
    build_query, mod = _load_build_query()
    expected_cols, ts = _infer_expectations(build_query)

    sig = None
    try:
        sig = inspect.signature(build_query)
    except Exception:
        pass

    mapcol = {"timestamp": ts, "select": expected_cols}

    try_calls = []
    if sig:
        params = [p for p in sig.parameters]
        if "mapcol" in params:
            try_calls.append(((mapcol,), {}))
            try_calls.append(((), {"mapcol": mapcol}))
        if "columns" in params:
            try_calls.append(((), {"columns": expected_cols}))
        if "select" in params and "columns" not in params:
            try_calls.append(((), {"select": expected_cols}))
        if "timestamp" in params:
            try_calls.append(((), {"timestamp": ts}))
        if "order_by" in params and "timestamp" not in params:
            try_calls.append(((), {"order_by": ts}))
    try_calls += [((mapcol,), {}), ((), {"mapcol": mapcol})]

    last_err = None
    for args, kwargs in try_calls:
        try:
            out = build_query(*args, **kwargs)
            break
        except Exception as e:  # pragma: no cover - best effort
            last_err = e
    else:
        pytest.fail(f"build_query call failed under all strategies: {last_err}")

    sql = None
    if isinstance(out, str):
        sql = out
    elif isinstance(out, (tuple, list)):
        for x in out:
            if isinstance(x, str) and "select" in x.lower():
                sql = x
                break
    if not isinstance(sql, str):
        pytest.fail("build_query did not return SQL string (directly or in tuple)")

    sel = _extract_select_cols(sql)
    for c in expected_cols:
        assert any(c.lower() in s.lower() for s in sel), (
            f"Missing column {c} in SELECT: {sel}"
        )

    assert re.search(rf"order\s+by\s{{1,}}{re.escape(ts)}\s+asc\b", sql, flags=re.I), (
        f"ORDER BY {ts} ASC missing in SQL: {sql}"
    )
