# Auto-generated by codex_workflow.py
# ruff: noqa: E701,E501
# mypy: ignore-errors
import importlib
import inspect
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parents[1]
# common sys.path adds
for add in [REPO_ROOT, REPO_ROOT / "src", REPO_ROOT / "app", REPO_ROOT / "lib"]:
    if add.exists() and add.as_posix() not in sys.path:
        sys.path.insert(0, add.as_posix())

WRITER_NAMES = [
    "log_message",
    "record_event",
    "append_message",
    "add_message",
    "log_event",
]


def _iter_module_names():
    base_dirs = [REPO_ROOT, REPO_ROOT / "src", REPO_ROOT / "app", REPO_ROOT / "lib"]
    seen = set()
    for base in base_dirs:
        if not base.exists():
            continue
        for p in base.rglob("*.py"):
            rel = p.relative_to(base).as_posix()
            if rel.startswith("tests/"):
                continue
            if rel.endswith("__init__.py"):
                mod = rel[:-12].replace("/", ".")
            else:
                mod = rel[:-3].replace("/", ".")
            if not mod or any(seg.startswith(".") for seg in mod.split(".")):
                continue
            if mod not in seen:
                seen.add(mod)
                yield mod


def resolve_fetch_messages():
    errors = {}
    for mod in _iter_module_names():
        try:
            m = importlib.import_module(mod)
        except Exception as e:
            errors[mod] = f"import error: {e}"
            continue
        if hasattr(m, "fetch_messages"):
            fn = getattr(m, "fetch_messages")
            try:
                sig = inspect.signature(fn)
            except Exception:
                sig = None
            meta = {
                "module": mod,
                "callable": fn,
                "accepts_db_path": (
                    "db" in (sig.parameters if sig else {})
                    or "db_path" in (sig.parameters if sig else {})
                    or (sig and any("path" in n for n in sig.parameters))
                ),
                "signature": str(sig) if sig else "unknown",
                "module_obj": m,
            }
            return meta
    return {"error": "fetch_messages not found", "errors": errors}


def resolve_writer():
    errors = {}
    for mod in _iter_module_names():
        try:
            m = importlib.import_module(mod)
        except Exception as e:
            errors[mod] = f"import error: {e}"
            continue
        for name in WRITER_NAMES:
            if hasattr(m, name):
                fn = getattr(m, name)
                try:
                    sig = inspect.signature(fn)
                except Exception:
                    sig = None
                params = sig.parameters if sig else {}
                if not any(k in params for k in ["session_id", "session", "sid"]):
                    continue
                return {
                    "module": mod,
                    "name": name,
                    "callable": fn,
                    "signature": str(sig) if sig else "unknown",
                    "accepts_db_path": (
                        sig
                        and any(
                            k in sig.parameters
                            for k in ["db", "db_path", "path", "database"]
                        )
                    ),
                }
    return {"error": "no writer found", "errors": errors}


def patch_default_db_path(module_obj, tmp_db_path):
    # Try to overwrite common constants if present
    patched = []
    for attr in [
        "DEFAULT_DB",
        "DB_PATH",
        "DEFAULT_DB_PATH",
        "MESSAGES_DB",
        "DEFAULT_LOG_DB",
    ]:
        if hasattr(module_obj, attr):
            try:
                setattr(module_obj, attr, str(tmp_db_path))
                patched.append(attr)
            except Exception:
                pass
    return patched
