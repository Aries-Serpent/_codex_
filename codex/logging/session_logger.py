# Auto-generated by codex_logging_workflow.py
from __future__ import annotations
import os, sqlite3, uuid
from pathlib import Path
from datetime import datetime

CODEX_DIR = Path(".codex")
CODEX_DIR.mkdir(parents=True, exist_ok=True)
DB_PATH = CODEX_DIR / "session_logs.db"
SESSION_ID_FILE = CODEX_DIR / "session_id"

def _ensure_db():
    conn = sqlite3.connect(DB_PATH)
    try:
        conn.execute("""CREATE TABLE IF NOT EXISTS messages (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            ts TEXT NOT NULL,
            session_id TEXT NOT NULL,
            role TEXT NOT NULL CHECK(role IN ('user','assistant')),
            content TEXT NOT NULL
        )""")
        conn.commit()
    finally:
        conn.close()

def get_session_id() -> str:
    sid = os.getenv("CODEX_SESSION_ID")
    if sid:
        return sid
    if SESSION_ID_FILE.exists():
        return SESSION_ID_FILE.read_text(encoding="utf-8").strip()
    sid = str(uuid.uuid4())
    SESSION_ID_FILE.write_text(sid, encoding="utf-8")
    return sid

def log_event(session_id: str, role: str, content: str) -> None:
    _ensure_db()
    conn = sqlite3.connect(DB_PATH)
    try:
        conn.execute(
            "INSERT INTO messages (ts, session_id, role, content) VALUES (?, ?, ?, ?)",
            (datetime.utcnow().isoformat() + "Z", session_id, role, content),
        )
        conn.commit()
    finally:
        conn.close()

def fetch_messages(session_id: str):
    _ensure_db()
    conn = sqlite3.connect(DB_PATH)
    try:
        cur = conn.execute(
            "SELECT ts, role, content FROM messages WHERE session_id=? ORDER BY id ASC",
            (session_id,),
        )
        return [{"ts": r[0], "role": r[1], "content": r[2]} for r in cur.fetchall()]
    finally:
        conn.close()
